#!/usr/bin/env python
from __future__ import print_function
import argparse
import errno
import getpass
import logging
# from typing import List, Any
import multiprocessing
import os
import os.path
import shutil
import sys
import time
import zipfile

import numpy
numpy.set_printoptions(precision=4, linewidth=100)

logging.basicConfig(level=logging.INFO)  # WARNING

# import non-standard packages
try:
    import openbabel
except ImportError:
    print("OpenBabel not found in your PYTHONPATH environment variable.")
    sys.exit()

try:
    import fragit
except ImportError:
    print("FragIt not found in your PYTHONPATH environment variable.")
    sys.exit()
else:
    import fragit.fragmentation
    from fragit.fragmentation import Fragmentation

try:
    import calcit
    import calcit.process
    import calcit.dalton
    from calcit.dalton import DALTONJob
except ImportError:
    print("CalcIt not found in your PYTHONPATH environment variable.")
    sys.exit()

try:
    import pepytools
except ImportError:
    print("pepytools not found in your PYTHONPATH environment variable.")
    sys.exit()
else:
    import pepytools.util
    import pepytools.fields
    import pepytools.tensor
    import pepytools.mulmom

has_h5py = False
try:
    import h5py
except ImportError:
    print("Warning: HDF5 not found. PDE calculations not supported.")
else:
    has_h5py = True

has_qml = False
try:
    import qml
except ImportError:
    print("Warning: QML not found. Machine-learned embedding potentials not supported.")
else:
    import spectre.ml
    import spectre.ml.prediction
    has_qml = True

from spectre.molecool.molecule import Molecule
from spectre.molecool.atom import Atom
from spectre.molecool.formatters import XYZMoleculeFormatter
from spectre.excited import SpectreExcitedStateData
import spectre.errors
import spectre.readers

aa2au = 1.8897261249935897
au2ev = 27.21138602

__doc__ = """
SPECTRE computes absorption spectra of chromophores in heterogenous
environments.

SPECTRE uses a three-step procedure to compute the exciton state of a molecule:
1) Compute embedding potential of ALL molecules in the input.
2) Compute excited state properties of each of the chromophores.
3) Assemble and compute elements of the Foerster matrix from 2) to obtain
   the coupled excited state spectrum of the chromophores.
"""


class DALTONLoPropJob(DALTONJob):
    """ A DALTON job to calculate LoProp properties """
    def __init__(self, basename, **kwargs):
        """ Initializes a DALTON LoProp calculation

            Arguments:
            basename -- name to use for the job

            Keyword Arguments:
            multipole_order -- order of the distributed multipoles (0 charges, 1 charges + dipoles, and so on)
            polarizability_order -- order of the polarizabilities. 0 none, 1: isotropic 2: anisotropic
        """
        self.mul_order = kwargs.get('multipole_order', 2)  # default to charges, dipoles and quadrupoles
        self.pol_order = kwargs.get('polarizability_order', 2)  # default to anisotropic dipole-polarizabilities
        DALTONJob.__init__(self, basename, **kwargs)
        self.runtype = 'loprop'

    def _program_substitutions(self):
        """ Substitutes information relevant
            Obtaining the LoProp parameters requires the program to
            know where DALTON is and where LoProp Is.
        """
        self._run_script_substitutions['PATH'] = os.environ.get('PATH')
        self._run_script_substitutions['LD_LIBRARY_PATH'] = os.environ.get('LD_LIBRARY_PATH')
        self._run_script_substitutions['PROGPATH'] = os.environ.get('DALTON')
        self._run_script_substitutions['LOPROP'] = os.environ.get('LOPROP')
        self._run_script_substitutions['MULMOM'] = "{0:d}".format(self.mul_order)
        self._run_script_substitutions['POLMOM'] = "{0:d}".format(self.pol_order)

    def __str__(self):
        return "DALTON LoProp ({0:s})".format(self.basename)

    def __repr__(self):
        return "DALTONLoPropJob('{0:s}')".format(self.basename)


class DALTONPDEJob(DALTONJob):
    """ A DALTON job to calculate PDE properties """
    def __init__(self, basename, **kwargs):
        DALTONJob.__init__(self, basename, **kwargs)

    def _program_substitutions(self):
        """ Substitutes information relevant
            Obtaining the LoProp parameters requires the program to
            know where DALTON is and where LoProp Is.
        """
        self._run_script_substitutions['PATH'] = os.environ.get('PATH')
        self._run_script_substitutions['LD_LIBRARY_PATH'] = os.environ.get('LD_LIBRARY_PATH')
        self._run_script_substitutions['PROGPATH'] = os.environ.get('DALTON')


class DALTONPDEMonomerJob(DALTONPDEJob):
    """ A DALTON job to calculate PDE properties """
    def __init__(self, basename, **kwargs):
        DALTONPDEJob.__init__(self, basename, **kwargs)
        self.runtype = 'pde_monomer'

    def __str__(self):
        return "DALTON PDE Monomer ({0:s})".format(self.basename)

    def __repr__(self):
        return "DALTONPDEMonomerJob('{0:s}')".format(self.basename)


class DALTONPDEDimerJob(DALTONPDEJob):
    """ A DALTON job to calculate PDE properties """
    def __init__(self, basename, **kwargs):
        DALTONPDEJob.__init__(self, basename, **kwargs)
        self.runtype = 'pde_dimer'

    def __str__(self):
        return "DALTON PDE Dimer ({0:s})".format(self.basename)

    def __repr__(self):
        return "DALTONPDEDimerJob('{0:s}')".format(self.basename)


class DALTONPEExEnergyJob(DALTONJob):
    """ A DALTON job to calculate embedded (PE) excitated state calculations
    """
    def __init__(self, basename, **kwargs):
        self.nexcited_states = kwargs.get('nexcited_states', 4)
        self.mprank = kwargs.get('mprank', 0)
        DALTONJob.__init__(self, basename, **kwargs)
        self.runtype = 'peex'

    def _program_substitutions(self):
        """ Substitutes information relevant
            Obtaining the LoProp parameters requires the program to
            know where DALTON is and where LoProp Is.
        """
        self._run_script_substitutions['PATH'] = os.environ.get('PATH')
        self._run_script_substitutions['LD_LIBRARY_PATH'] = os.environ.get('LD_LIBRARY_PATH')
        self._run_script_substitutions['PROGPATH'] = os.environ.get('DALTON')

        self._comp_chem_substitutions['NEXCITATIONS'] = self.nexcited_states
        self._comp_chem_substitutions['MPRANK'] = self.mprank

    def __str__(self):
        return "DALTON PE-EX ({0:s})".format(self.basename)

    def __repr__(self):
        return "DALTONPEExEnergyJob('{0:s}')".format(self.basename)


class DALTONPDEExEnergyJob(DALTONPEExEnergyJob):
    def __init__(self, basename, **kwargs):
        DALTONPEExEnergyJob.__init__(self, basename, **kwargs)
        self.runtype = 'pdeex'

    def _program_substitutions(self):
        """ Substitutes information relevant
            Obtaining the LoProp parameters requires the program to
            know where DALTON is and where LoProp Is.
        """
        self._run_script_substitutions['PATH'] = os.environ.get('PATH')
        self._run_script_substitutions['LD_LIBRARY_PATH'] = os.environ.get('LD_LIBRARY_PATH')
        self._run_script_substitutions['PROGPATH'] = os.environ.get('DALTON')
        self._run_script_substitutions['PDEOPT'] = "-put \"{}.h5\"".format(self.basename)

        self._comp_chem_substitutions['NEXCITATIONS'] = self.nexcited_states
        self._comp_chem_substitutions['MPRANK'] = self.mprank
        self._comp_chem_substitutions['PDEFILE'] = "{}.h5".format(self.basename)

    def __str__(self):
        return "DALTON PDE-EX ({0:s})".format(self.basename)

    def __repr__(self):
        return "DALTONPDEExEnergyJob('{0:s}')".format(self.basename)


class SpectrePDEData(object):
    """ Representation of PDE data in SPECTRE """
    def __init__(self, num_bas, num_pols):
        self._num_bas = num_bas
        self._num_pols = num_pols

    def get_num_bas(self):
        return self._num_bas

    def get_num_pols(self):
        return self._num_pols


class ExpandPath(argparse.Action):
    """ Custom ArgumentParser action to expand absolute paths """
    def __call__(self, parser, namespace, values, option_string=None):
        if values is None:
            setattr(namespace, self.dest, None)
        else:
            setattr(namespace, self.dest, os.path.abspath(values))


def header(text, level, default_width=50):
    """ Utility function to generate header strings """
    min_width = len(text) * 2
    width = max(default_width, min_width)
    if level == 0:
        outer_bar = "+{0:s}+".format("".join((width-2)*["-"]))
        inner_bar = "|{0:s}|".format("".join((width - 2) * ["-"]))
        fmts = "{0:s}\n{1:s}\n|{2:^" + "{0:d}".format(width-2) + "}|\n{1:s}\n{0:s}"
        return fmts.format(outer_bar, inner_bar, text)

    if level == 1:
        width = min(default_width, min_width)
        bar = "".join(width*["-"])
        fmts = "{0:s}\n{1:^" + "{0:d}".format(width) + "}\n{0:s}"
        return fmts.format(bar, text)
    elif level == 2:
        return "**** {0:s} ****".format(text)

# ---------------------------------------------
# ---------------------------------------------
# ---------------------------------------------


def setup_chromophores(args):
    """ Slim version of PEAS to generate potentials

        This method performs many tasks:

          - extract chromophores from the supplied input
          - generate potentials from the supplied input
            following ideas from PEAS albeit in a way
            more restricted form
          - Generate the PCM surface for use in PCM
            calculations

        Returns:
        lists of molecules, chromophore indices, potentials and a pcm surface
    """
    if args.verbose:
        print(header("GENERATING POTENTIALS", 0))

    # first step is to fragment everything
    if args.verbose:
        print(">>>> OUTPUT FROM FRAGIT <<<<")
    molecule = obmolecule_from_filename_and_format(args.input)
    fragmentation = Fragmentation(molecule, conffile=args.frag_settings, verbose=False)
    fragmentation.setVerbose(args.verbose)
    fragmentation.beginFragmentation()
    fragmentation.doFragmentation()
    fragmentation.finishFragmentation()

    if args.verbose:
        print(">>>> END <<<<")
        print()

    # molecule representation of each fragment
    molecules = list(generate_molecules(molecule, fragmentation))

    # generate LoProp embedding potentials
    potentials, names = generate_loprop_potentials(molecules, args)

    # make a subset of fragments that are chromophores
    # and their surrounding potentials
    chromophores = [i for i, x in enumerate(molecules) if x.get_name() in args.c]

    return molecules, chromophores, potentials


def obmolecule_from_filename_and_format(filename, file_format='pdb'):
    """ Reads a molecule from disk into an OpenBabel molecule.

        :param filename: the file to load
        :type filename: str
        :param file_format: file format to load
        :type file_format: str

        :return: OpenBabel OBMol instance of the molecule
        :rtype: openbabel.OBMol
    """
    obc = openbabel.OBConversion()
    obc.SetInFormat(file_format)
    mol = openbabel.OBMol()
    obc.ReadFile(mol, filename)
    return mol


def generate_molecules(obmol, frag):
    """ Generates all molecules based on :class:`Fragmentation`

        :param obmol: the openbabel molecule
        :type obmol: openbabel.OBMol
        :param frag: the fragmentation results
        :type frag: fragit.fragmentation.Fragmentation
    """
    frag_indices = frag.getFragments()
    frag_names = frag.getFragmentNames()
    frag_charges = frag.getFragmentCharges()
    for i, (name, indices, charge) in enumerate(zip(frag_names, frag_indices, frag_charges)):
        yield build_molecule_from_fragment(obmol, indices, name, charge)


def build_molecule_from_fragment(obmol, atom_indices, name, charge):
    """ Builds molecule from fragmentation data and :class:`openbabel.OBMol` a molecule.

        :param obmol: the openbabel molecule
        :type obmol: openbabel.OBMol
        :param atom_indices: atom indices in the entire structure from the fragmentation
        :type atom_indices: list[int]
        :param name: the name of the molecule
        :type name: str
        :param charge: molecular charge for the fragment
        :type charge: int
        :return: the molecule representation of the fragment
        :type: Molecule
    """
    mol = Molecule()
    mol.set_name(name)
    mol.set_charge(charge)

    for atom_index in atom_indices:
        obatom = obmol.GetAtom(atom_index)
        mol.add_atom(Atom(obatom.GetAtomicNum(),
                    xyz=[obatom.GetX(), obatom.GetY(), obatom.GetZ()]))

    return mol


def generate_loprop_potentials(molecules, args):
    """ Generates potentials for all molecules in argument list

        SPECTRE uses the CalcIt framework to process individual jobs

        :param list[molecool.Molecule] molecules:
        :param argparse.Namespace args: spectre settings object
        :return: list of potentials
        :rtype: list[pepytools.potential.Potential]
    """

    if args.verbose:
        print(header("LoProp Settings:", 1))

        functional = "RHF"
        basis = args.potential_loprop_basis
        if args.potential_functional is not None:
            functional = args.potential_functional

        if args.use_ml:
            print_option("machine learning", "charge/isotropic dipole potential where possible", "{0:s}")
            print("")

        print_option("theory", "{0}/{1}".format(functional, basis), "{0:s}")

        stat_pot = "charges, dipoles and quadrupoles"
        dyna_pot = "electric dipole-dipole polarizabilities"
        if args.do_isopol:
            dyna_pot = "isotropic electric dipole-dipole polarizabilities"

        if not args.do_polarization:
            dyna_pot = "none"

        print_option("static potential", stat_pot, "{0:s}")
        print_option("dynamic potential", dyna_pot, "{0:s}")
        print("")
        if args.potential_loprop_script is not None:
            print_option("custom run script", args.potential_loprop_script, "{0:s}")
            print("")

        print_option("jobs per node", args.potential_jobs_per_node, "{0:d}")
        print_option("cpus per job", args.potential_cpus_per_job, "{0:d}")
        print("")

    # base working directory for job
    base = os.path.splitext(args.input)[0]
    safe_create_dir(base)
    os.chdir(base)

    # generate .xyz files for all molecules (needed by multiple steps below)
    for i, molecule in enumerate(molecules, start=1):
        name = "{0:04d}_{1:s}".format(i, molecule.get_name())
        try:
            os.chdir(name)
        except FileNotFoundError:  # directory not found
            safe_create_dir(name)
            os.chdir(name)
        formatter = XYZMoleculeFormatter(molecule)
        with open("{}.xyz".format(name), 'w') as xyzfile:
            xyzfile.write(str(formatter))
        os.chdir("..")

    # if ML is used, we make loprop files from QML
    # we can later use this with the distance criterion to only compute
    # some of the embedding potential with QML and the rest will be computed
    if args.use_ml:
        build_qml_loprop_jobs(molecules, args)

    # generate calcit jobs for DALTON LoProp calculation
    jobs, job_names = build_calcit_dalton_loprop_jobs(molecules, args)

    # process jobs
    process_calcit_jobs(jobs, args.potential_jobs_per_node, args.is_dryrun)

    # now all the initial loprop files should be ready, let us generate
    # potentials needed for embedding calculations later on.
    potentials = [build_loprop_potential(molecule, name) for molecule, name in zip(molecules, job_names)]
    return potentials, job_names


def build_qml_loprop_jobs(molecules, args):
    """ Builds LoProp output files from QML predictions

    :param molecules: the molecules for which to generate potential parameters.
    :type molecules: list[Molecule]
    :param args: spectre settings object
    :type args: argparse.Namespace
    """

    # store molecule names and indices so we can get parameters only for the
    # molecules we know
    molecule_names = {}
    filenames = []
    for i, molecule in enumerate(molecules, start=1):
        mol_name = molecule.get_name()
        if mol_name not in molecule_names:
            molecule_names[mol_name] = []
        molecule_names[mol_name].append(i-1)  # adds molecule index to list for later use
        name = "{0:04d}_{1:s}".format(i, mol_name)
        filename = "{0}/{0}.xyz".format(name)
        filenames.append(filename)

        # unpack a potential zipfile with properties of a single
        # molecule: potential and possible excitation calculations.
        if zipfile.is_zipfile(name + ".zip"):
            with zipfile.ZipFile(name + ".zip") as zf:
                zf.extractall()

    # load ML data from file
    for molecule_name in molecule_names:
        ml_path = os.path.join(args.ml_path, "{0:s}.npz".format(molecule_name))
        if os.path.isfile(ml_path):
            with numpy.load(ml_path) as ml_data:
                # extract the molecules we know about
                indices = molecule_names[molecule_name]
                ex_molecules = [molecules[i] for i in indices]
                ex_filenames = [filenames[i] for i in indices]
                if not args.is_dryrun:
                    write_qml_loprop_files(ex_molecules, ex_filenames, ml_data)
                    cleanup_work_directories(ex_molecules)
        else:
            print("ML parameters for {} not found. They will be calculated with LoProp.".format(molecule_name))


def write_qml_loprop_files(molecules, filenames, ml_data):
    """ Predicts atomic properties from QML and writes all files to disk

    :param molecules:
    :param filenames:
    :param ml_data:
    :return:
    """

    # we need TWO sets of alphas, i.e. one for charges and one for polarizabilites
    all_charges, all_pols, max_size = spectre.ml.prediction.atomic_properties(filenames, ml_data)

    for i, molecule in enumerate(molecules, start=1):
        i_from = (i - 1) * max_size
        i_to = i * max_size

        # make sure atomic charges are integer charges
        mol_charges = all_charges[i_from:i_to]
        sum_charges = sum(mol_charges)
        mol_charges -= sum_charges / max_size
        mol_pols = all_pols[i_from:i_to]
        mol_coord = molecule.get_coordinates() * aa2au
        name = "{0:04d}_{1:s}".format(i, molecule.get_name())
        try:
            os.chdir(name)
        except FileNotFoundError:
            raise spectre.errors.SpectreLopropFolderNotFoundError("No such file or directory: '{}'".format(name))
        else:
            write_qml_loprop_file(mol_coord, mol_charges, mol_pols, name, max_size)
            os.chdir("..")


def write_qml_loprop_file(mol_coord, mol_charges, mol_pols, mol_name, max_size):
    """ Writes a single

    :param mol_coord: Coordinates of the molecule to write to the loprop file
    :param mol_charges: atomic partial charges
    :param mol_pols: atomic polarizabilities
    :param mol_name: the name of the molecule
    :param max_size: the number of atoms in the molecule
    :return:
    """
    s = "AU\n"
    s += "{0:d} {1:d} {2:d} 1\n".format(max_size, 0, 1)  # m0p1 potential
    for c, q, p in zip(mol_coord, mol_charges, mol_pols):
        s += "1 {0[0]:16.9f}{0[1]:16.9f}{0[2]:16.9f}{1:16.9f}{2:16.9f}\n".format(c, q, p)
    s += "\nTime used in (ML) Loprop              :      0.00 (cpu)       0.00 (wall)"
    with open("{0:s}_dalton_loprop.loprop".format(mol_name), 'w') as loprop_file:
        loprop_file.write(s)


def build_calcit_dalton_loprop_jobs(molecules, args):
    """ Builds DALTON LoProp jobs and files for calcit

        WARNING: The `job_names` array is used to construct _ALL_ the potentials
                 later and cannot be altered or used to create a shorter list.
                 However, since `job_names` below must _always_ have _all_
                 possible names, but the `jobs` array can be shorter.

        :param molecules: the molecules for which to generate potential parameters.
        :type molecules: list[Molecule]
        :param args: spectre settings object
        :type args: argparse.Namespace
        :return: list of jobs for calcit and associated list of job names.
        :rtype: tuple[list[DALTONJob], list[str]]
    """
    job_names = []
    jobs = []
    for i, molecule in enumerate(molecules, start=1):
        name = "{0:04d}_{1:s}".format(i, molecule.get_name())

        # unpack a potential zipfile with properties of a single
        # molecule: potential and possible excitation calculations.
        if zipfile.is_zipfile(name + ".zip"):
            with zipfile.ZipFile(name + ".zip") as zf:
                zf.extractall()

        # building a potential is free provided the necessary files are there
        # so we will check for any exceptions raised during attempting to
        # build a potential (but wait for later to actually build it)
        try:
            build_loprop_potential(molecule, name)
        except (spectre.errors.SpectreLopropFolderNotFoundError,
                spectre.errors.SpectreLopropFileNotFoundError) as e:

            if type(e) is spectre.errors.SpectreLopropFolderNotFoundError:
                safe_create_dir(name)

            if type(e) is spectre.errors.SpectreLopropFileNotFoundError:  # log-file is not found but we managed to change dir
                os.chdir('..')

            os.chdir(name)
            jobs.append(build_calcit_dalton_loprop_job(molecule, name, args))
            os.chdir("..")
        finally:
            # we always add the job name because we need it for later
            job_names.append(name)

    return jobs, job_names


def process_calcit_jobs(jobs, jobs_per_node, is_dryrun):
    """ Processes all CalcIt jobs given as input

    :param jobs: the jobs to process
    :type jobs: list
    :param jobs_per_node: number of jobs to execute per node
    :type jobs_per_node: int
    :param is_dryrun: whether or not the the job should execute
    :type is_dryrun: bool
    """
    port = 2048
    authorization_key = calcit.util.generate_auth_key("auto")
    nodes = build_hostlist()
    work_dir = os.getcwd()
    remote_shell = 'ssh'
    calcit_paths = calcit.util.directories(os.environ['CALCIT'] + '/bin/calcit')
    do_execute = not is_dryrun
    calcit.process_jobs(port, authorization_key,
                        jobs, nodes, jobs_per_node,
                        work_dir, remote_shell,
                        calcit_paths, do_execute)


def print_option(key, value, val_fmt, indent=2, width=27):
    """ Prints options

    :param key: the keyword to use
    :param value: the value to present
    :param val_fmt: the format for the value
    :param indent: indentation level
    :param width: the width of the statement
    :return:
    """
    indent_fmt = "{0:>" + str(indent + 4) + "s}"
    fmt_key = indent_fmt.format("{0:<") + "{0:d}".format(width-indent) + "s}:"
    fmt_value = val_fmt.format(value)
    print(fmt_key.format(key) + " " + fmt_value)

def safe_create_dir(path):
    """ Creates a directory safely

        If the directory already exists no error is thrown but in any other case
        the error is re-raised

        Arguments:
        path -- the path to create
    """
    try:
        os.makedirs(path)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise


def build_calcit_dalton_loprop_job(molecule, name, args):
    """ Sets up a LoProp calculation through DALTON

        Arguments:
        molecule -- the molecule
        name -- name of the molecule internally to spectre
        args -- spectre options

        Returns:
        DALTON LoProp Job
    """

    write_molecule_to_xyz(molecule, name)

    # choose level of multipoles
    mul_order = args.potential_multipole_order

    # choose level of polarizabilities
    pol_order = 2
    if args.do_isopol:
        pol_order = 1
    if not args.do_polarization:
        pol_order = 0

    return DALTONLoPropJob(name,
                           custom_run_script=args.potential_loprop_script,
                           charge=molecule.get_charge(),
                           basis_set=args.potential_loprop_basis,
                           cores_per_job=args.potential_cpus_per_job,
                           scratch_directory=args.scratch_directory,
                           dft_functional=args.potential_functional,
                           multipole_order=mul_order,
                           polarizability_order=pol_order)


def write_molecule_to_xyz(molecule, name):
    """ Writes a molecule to .xyz file

        :param molecule: the molecule to write to xyz file
        :param name: the name of the molecule (will also be the filename)
        :type molecule: Molecule
        :type name: str
    """
    formatter = XYZMoleculeFormatter(molecule)
    with open("{0:s}.xyz".format(name), 'w') as xyz_file:
        xyz_file.write(str(formatter))


def generate_pde_potentials(molecules, chroms, pots, args):
    """ Generates potentials for all molecules in argument list

        SPECTRE uses the CalcIt framework to process individual jobs

        Arguments:
        molecules -- structures which is used to generate embedding potentials
        args -- spectre options

        Returns:
        list of potentials corresponding to the molecules on input
    """

    if args.verbose:
        print(header("PDE Settings:", 1))

        functional = "RHF"
        if args.potential_functional is not None:
            functional = args.potential_functional
        print_option("theory", "{0}/{1}".format(functional, args.potential_pde_basis), "{0:s}")

        if args.potential_pde_mon_script is not None:
            print_option("custom monomer script", args.potential_pde_mon_script, "{0:s}")
        if args.potential_pde_dim_script is not None:
            print_option("custom dimer script", args.potential_pde_dim_script, "{0:s}")
        print("")

        print_option("jobs per node", args.potential_jobs_per_node, "{0:d}")
        print_option("cpus per job", args.potential_cpus_per_job, "{0:d}")

    # generate calcit jobs for DALTON PDE Monomer calculations
    jobs, job_names = build_calcit_dalton_pde_monomer_jobs(molecules, chroms, pots, args)
    process_calcit_jobs(jobs, args.potential_jobs_per_node, args.is_dryrun)

    # generate calcit jobs for DALTON PDE Dimer calculations
    jobs, job_names = build_calcit_dalton_pde_dimer_jobs(molecules, chroms, pots, args)
    process_calcit_jobs(jobs, args.potential_jobs_per_node, args.is_dryrun)

    # print("PDE PDE PDE")
    # print()

    # we build PDE potentials for each chromophore
    # the jobs are stored on disk and no data is tranferred here.
    build_pde_potentials(chroms, molecules, args.potential_pde_exch_factor)

    return job_names


def build_calcit_dalton_pde_monomer_jobs(molecules, chroms, pots, args):
    """ Builds DALTON PDE jobs and files for calcit

        WARNING: The `job_names` array is used to construct _ALL_ the potentials
                 later and cannot be altered or used to create a shorter list.
                 However, since `job_names` below must _always_ have _all_
                 possible names, but the `jobs` array can be shorter.

        Arguments:
        molecules -- structures which is used to generate embedding potentials
        args -- spectre options

        Returns:
        list of jobs for calcit and associated list of job names.
    """
    # we have two subjobs to complete for each chromophore
    jobs = []
    job_names = []

    for i, ii in enumerate(chroms, start=1):
        mi = molecules[ii]

        i_chrom_name = "{0:04d}_{1:s}".format(i, mi.get_name())  # TODO: maybe fix because i and ii are different beasts.

        # unpack a potential zipfile with properties of a single
        # molecule: potential and possible excitation calculations.
        for j, (mj, pj) in enumerate(zip(molecules, pots), start=1):
            if i == j:
                continue

            name = "{0:s}_{1:04d}_{2:s}".format(i_chrom_name, j, mj.get_name())

            if zipfile.is_zipfile(name + ".zip"):
                with zipfile.ZipFile(name + ".zip") as zf:
                    zf.extractall()

            safe_create_dir(name)
            os.chdir(name)

            potential = build_chromophore_potential(pots, args, ii)
            potential.save('temp.pot')
            write_monomer_h5_file(mi, mj, name)
            write_molecule_to_xyz(mj, name)
            jobs.append(build_calcit_dalton_pde_monomer_job(mj, name, args))
            job_names.append(name)

            os.chdir("..")

    return jobs, job_names


def write_monomer_h5_file(mi, mj, name):
    """ Writes initial PDE monomer file

        :param mi: core molecule
        :param mj: embedding molecule
        :param name: name of file
        :type name: str

    """
    with h5py.File("{0:s}_dalton_pde_monomer.h5".format(name), 'w') as h5:
        # store core (chromophore) properties
        try:
            core = h5.create_group("core_fragment")
        except ValueError:  # group already exists
            core = h5['core_fragment']
        finally:
            core['num_nuclei'] = mi.get_num_atoms()
            core['charges'] = [a.get_nuclear_charge() for a in mi.get_atoms()]
            core['coordinates'] = mi.get_coordinates() * aa2au

        # store properties of other fragment
        try:
            fragment = h5.create_group("fragment")
        except ValueError:  # group already exists
            fragment = h5['fragment']
        finally:
            fragment['num_nuclei'] = mj.get_num_atoms()
            fragment['charges'] = list([a.get_nuclear_charge() for a in mj.get_atoms()])
            fragment['coordinates'] = mj.get_coordinates() * aa2au


def build_calcit_dalton_pde_monomer_job(molecule, name, args):
    return DALTONPDEMonomerJob(name,
                               custom_run_script=args.potential_pde_mon_script,
                               charge=molecule.get_charge(),
                               basis_set=args.potential_pde_basis,
                               cores_per_job=args.potential_cpus_per_job,
                               scratch_directory=args.scratch_directory,
                               dft_functional=args.potential_functional,
                               )


def build_calcit_dalton_pde_dimer_jobs(molecules, chroms, pots, args):
    """ Builds DALTON PDE jobs and files for calcit

        WARNING: The `job_names` array is used to construct _ALL_ the potentials
                 later and cannot be altered or used to create a shorter list.
                 However, since `job_names` below must _always_ have _all_
                 possible names, but the `jobs` array can be shorter.

        Arguments:
        molecules -- structures which is used to generate embedding potentials
        args -- spectre options

        Returns:
        list of jobs for calcit and associated list of job names.
    """
    # make potential for everything. Needed to store static part of potential
    # we have two subjobs to complete for each chromophore
    jobs = []
    job_names = []

    for i, ii in enumerate(chroms, start=1):
        mi = molecules[ii]

        i_chrom_name = "{0:04d}_{1:s}".format(i, mi.get_name())

        for j, (mj, pj) in enumerate(zip(molecules, pots), start=1):
            if i == j:
                continue

            name = "{0:s}_{1:04d}_{2:s}".format(i_chrom_name, j, mj.get_name())
            os.chdir(name)

            # also dump .xyz file with combined molecule
            mol_combined = Molecule.from_molecule(mi)
            mol_combined.addAtoms(*list(mj.get_atoms()))
            write_molecule_to_xyz(mol_combined, name)

            jobs.append(build_calcit_dalton_pde_dimer_job(mol_combined, name, args))
            job_names.append(name)

            os.chdir("..")

    return jobs, job_names


def build_calcit_dalton_pde_dimer_job(molecule, name, args):
    return DALTONPDEDimerJob(name,
                             custom_run_script=args.potential_pde_dim_script,
                             charge=molecule.get_charge(),
                             basis_set=args.potential_pde_basis,
                             cores_per_job=args.potential_cpus_per_job,
                             scratch_directory=args.scratch_directory,
                             dft_functional=args.potential_functional,
                             )


def build_pde_potentials(chroms, molecules, repulsion_scale_factor):
    """ Builds PDE potential files (.h5) from the PDE data for all chromophores

        and writes it to disk.

        This method can raise two different exceptions:
        IOError -- if the file is not found
        OSError -- if the scratch directory is not found

        Arguments:
        mols -- the molecule for which to construct the potential for

        Returns:
        The potential
    """
    print("building PDE potentials:")

    pde_parms = chromophore_pde_parameters(chroms, molecules)

    for i, ii in enumerate(chroms, start=1):
        mi = molecules[ii]
        i_chrom_name = "{0:04d}_{1:s}".format(i, mi.get_name())

        i_chrom_parm = pde_parms[ii]
        num_bas = i_chrom_parm.get_num_bas()
        num_pols = i_chrom_parm.get_num_pols()

        nuc_el_energy = 0.0
        nuc_coordinates = []
        nuc_charges = []
        repulsion_matrix = numpy.zeros(num_bas*(num_bas+1)//2)
        electrostatic_matrix = numpy.zeros(num_bas*(num_bas+1)//2)
        fd_static_field = numpy.zeros(3*num_pols)

        print("\n  - chromophore:", mi.get_name())

        for j, mj in enumerate(molecules, start=1):
            if i == j:
                continue

            name = "{0:s}_{1:04d}_{2:s}".format(i_chrom_name, j, mj.get_name())
            print("    - :", j, mj.get_name())
            os.chdir(name)

            with h5py.File("{}_dalton_pde_dimer.h5".format(name), "r") as h5file:
                prefactor = 1.0  # for MFCC we should change to +/- 1
                nuc_el_energy += prefactor * h5file['core_fragment']['nuclear-electron energy'][()]
                electrostatic_matrix += prefactor * h5file['core_fragment']['electrostatic matrix'][()]
                repulsion_matrix += prefactor * repulsion_scale_factor * h5file['core_fragment']['exchange-repulsion matrix'][()]

                nuc_coordinates.extend(h5file['fragment']['coordinates'])
                nuc_charges.extend([prefactor * charge for charge in h5file['fragment']['charges']])
                fd_static_field += prefactor * h5file['fragment']['electric fields'][()]

            os.chdir("..")

        # now we write the final chromophore file to the chromophore directory
        # if it already exists, we delete it first because with h5 you cannot
        # 'simply' overwrite values
        os.chdir(i_chrom_name)
        print("  - cwd:", os.getcwd())
        if os.path.exists("{}.h5".format(i_chrom_name)):
            os.remove("{}.h5".format(i_chrom_name))

        with h5py.File("{}.h5".format(i_chrom_name), "w") as h5file:
            h5file["num_bas"] = num_bas
            h5file["num_fields"] = num_pols
            h5file["num_nuclei"] = numpy.int32(len(nuc_coordinates))
            h5file["electrostatic matrix"] = electrostatic_matrix
            h5file["exchange-repulsion matrix"] = repulsion_matrix
            h5file["nuclear charges"] = nuc_charges
            h5file["nuclear coordinates"] = nuc_coordinates
            h5file["nuclear-electron energy"] = nuc_el_energy
            h5file["electric fields"] = fd_static_field
        os.chdir("..")


def chromophore_pde_parameters(chroms, molecules):
    """Retrieves PDE properties for all chromophores in the system

    :param chroms: chromophores in the system
    :type chroms: list[int]
    :param molecules: molecules in the system
    :type molecules: list[Molecule]
    :return: pde parameters
    :rtype: list[SpectrePDEData]
    """

    data = []

    for i, ii in enumerate(chroms, start=1):
        mi = molecules[ii]
        i_chrom_name = "{0:04d}_{1:s}".format(i, mi.get_name())

        for j, mj in enumerate(molecules, start=1):
            if i == j:
                continue

            name = "{0:s}_{1:04d}_{2:s}".format(i_chrom_name, j, mj.get_name())
            os.chdir(name)
            data.append(pde_parameters_from_file(name))
            os.chdir("..")
            break  # just need the first one to get the data

    assert len(data) == len(chroms)
    return data


def pde_parameters_from_file(name):
    print(" -- reading pde parameters from file: '{}_dalton_pde_dimer.h5' -- ".format(name))
    with h5py.File("{}_dalton_pde_dimer.h5".format(name), "r") as h5file:
        num_bas = h5file['core_fragment']['num_bas'][0]
        num_pols = h5file['fragment']['num_pols'][0]

        return SpectrePDEData(num_bas, num_pols)


def build_hostlist():
    """ Build and return hostlist for the current machine

        The hostlist generation is *only* implemented for localhost and SLURM.

        :return: the nodelist to use for jobs
        :rtype: list[str]

        .. note::
        If running through the SLURM queue system on a compute cluster the system will spawn jobs on each node assigned to the job
    """

    # by default, we just assume that we are running
    # on one node (i.e. the one we are running on)
    nodes = ['localhost']  # [socket.gethostname()]

    slurm_nodelist = os.environ.get("SLURM_NODELIST", None)
    if slurm_nodelist is not None:
        o, e, dt = calcit.process.execute("scontrol show hostname")
        # in python3 we might get a series of bytes and not
        # a regular python string from the above, thus
        # we need to decode it
        nodes = [n.decode('utf-8') for n in set(o.split())]

    return nodes


def build_loprop_potential(mol, name):
    """ Builds a :class:`pepytools.Potential` from the LoProp data and optionally (currently never) writes it to disk.

        :param mol: the molecule for which to construct the potential for
        :type mol: Molecule
        :param name: the name (base of filename) of the file associated with the molecule
        :type name: str

        :raises spectre.errors.SpectreLopropFolderNotFoundError: The Loprop folder can not be found.

        :returns: The potential
        :rtype: pepytools.Potential
    """
    try:
        os.chdir(name)
    except FileNotFoundError:
        raise spectre.errors.SpectreLopropFolderNotFoundError("No such file or directory: '{}'".format(name))

    potential = potential_from_loprop_data(mol, name)
    os.chdir("..")
    return potential


def potential_from_loprop_data(mol, name):
    """ Reads a LoProp data file and constructs a :class:`pepytools.Potential` from it

        :param mol: the molecule for which to construct the potential for
        :type mol: Molecule
        :param name: the name (base of filename) of the file associated with the molecule
        :type name: str

        :raises spectre.errors.SpectrePotentialValueError: The Loprop file can not be found.

        :returns: The potential
        :rtype: pepytools.Potential
    """
    mul_offset = {0: 1, 1: 3, 2: 6}
    pol_offset = {1: 1, 2: 6}

    mul_data = {}
    pol_data = []

    coords = mol.get_coordinates() * aa2au
    labels = [atom.get_label() for atom in mol.get_atoms()]

    filename = "{0:s}_dalton_loprop.loprop".format(name)
    if not os.path.exists(filename):
        raise spectre.errors.SpectreLopropFileNotFoundError("No such file or directory: '{}'".format(filename))
    with open(filename, 'r') as loprop_file:
        line = loprop_file.readline()  # AA or AU
        if "AA" in line:
            raise spectre.errors.SpectrePotentialValueError("Expected units to be in AU.")

        nat, lmax, amax, dum = list(map(int, loprop_file.readline().split()))
        if nat == 0:
            raise spectre.errors.SpectrePotentialValueError("No atoms found.")
        if lmax > 2:
            raise spectre.errors.SpectrePotentialValueError("Only supports up to quadrupoles.")
        if amax > 2:
            raise spectre.errors.SpectrePotentialValueError("Does not support polarizability tensors with dim > 2.")

        for i in range(nat):
            # skip coordinates in the data
            tokens = list(map(float, loprop_file.readline().split()))[4:]
            for l in range(lmax+1):
                if l not in mul_data:
                    mul_data[l] = []

                offset = mul_offset[l]
                mul_data[l].append(tokens[0:offset])
                tokens = tokens[offset:]

            if amax == 0:
                continue

            if len(tokens) == pol_offset[amax]:
                if len(tokens) == 1:
                    pol_data.append([tokens[0], 0.0, 0.0, tokens[0], 0.0, tokens[0]])
                else:
                    pol_data.append(tokens)
            else:
                raise spectre.errors.SpectrePotentialValueError("Nope")

    pot = pepytools.Potential()
    pot.coordinates = coords
    pot.labels = labels
    pot.multipoles = mul_data

    #
    if len(pol_data) > 0:
        excl_data = {}
        serials = range(mol.get_num_atoms())
        for i in serials:
            excl_atom = []
            for j in serials:
                if i == j:
                    continue

                excl_atom.append(j)
            excl_data[i] = numpy.array(excl_atom)

        pot.polarizabilities = pol_data
        pot.exclusion_list = excl_data

    return pot

# ---------------------------------------------
# ---------------------------------------------
# ---------------------------------------------


def compute_chromophores(molecules, potentials, chromophores, args):
    """ Computes excited state properties for the supplied list of chromophores

        :param molecules: the list of molecules
        :type molecules: list[Molecule]
        :param potentials: list of potentials
        :type potentials: list[pepytools.Potential]
        :param chromophores: list of indices for which molecules are chromophores
        :type chromophores: list[int]
        :param args: spectre settings object
        :type args: argparse.Namespace
        :return: list of excited state data.
        :rtype: list[SpectreExcitedStateData]
    """

    if args.verbose:
        print(header("COMPUTING CHROMOPHORE EXCITED STATE PROPERTIES", 0))

        print(header("Excited State Settings:", 1))
        functional = "RHF"
        if args.ex_functional is not None:
            functional = args.ex_functional

        pde_status = "PE"
        if args.do_pde:
            pde_status = "PDE"
        print_option("polarizable density embedding", pde_status, "{0}")
        theory = "{0}-{1}/{2}".format(pde_status, functional, args.ex_basis)
        print_option("theory", theory, "{0:s}")

        if args.potential is not None:
            print_option("external potential", args.potential, "{0}")

        print_option("chromophore names", "{0}".format(", ".join(args.c)), "{0:s}")
        print_option("number of states", args.ex_n, "{0:d}")

        states = "all"
        if args.ex_state > 0:
            states = "{0}".format(args.ex_state)
        print_option("coupling states", states, "{0}")
        print("")

        if args.ex_script is not None:
            print_option("custom run script", format(args.ex_script), "{}")
            print("")

        print_option("jobs per node", args.potential_jobs_per_node, "{0:d}")
        print_option("cpus per job", args.potential_cpus_per_job, "{0:d}")

    jobs, job_names = build_calcit_dalton_ex_jobs(molecules, potentials, chromophores, args)
    process_calcit_jobs(jobs, args.ex_jobs_per_node, args.is_dryrun)

    data = read_computed_chromophore_properties(molecules, chromophores, job_names, args)
    assert(len(data) == len(chromophores))

    s_out = ""
    for i, p in enumerate(data, start=1):
        s_out += "{0:s}\n".format(output_dalton_ex_data(p.get_excitation_energies(), p.get_oscillator_strengths(), idx=i))
    if args.verbose:
        print(s_out)

    if args.write_file:
        base = os.path.splitext(args.input)[0]
        filename = "{0}_uncoupled.dat".format(base)
        with open(filename, "w") as f:
            f.write(s_out)

    return data


def build_calcit_dalton_ex_jobs(molecules, pots, chromophores, args):
    """ Builds list of DALTON jobs for excited state calculations

        :param molecules: list of molecules in system
        :param pots: list of potentials
        :type pots: list[pepytools.Potential]
        :param chromophores: list of chromophores
        :type chromophores: list[int]
        :param args: spectre settings object
        :type args: argparse.Namespace
        :return: a list of jobs and jobnames
        :rtype: tuple[list[DALTONJob], list[str]]
    """
    job_names = []
    jobs = []
    for i, i_chromophore in enumerate(chromophores, start=1):
        molecule = molecules[i_chromophore]
        potential = build_chromophore_potential(pots, args, i_chromophore)

        name = "{0:04d}_{1:s}".format(i, molecule.get_name())

        safe_create_dir(name)
        os.chdir(name)

        if not args.do_pde:
            jobs.append(
                DALTONPEExEnergyJob(name,
                                    charge=molecule.get_charge(),
                                    custom_run_script=args.ex_script,
                                    basis_set=args.ex_basis,
                                    cores_per_job=args.ex_cpus_per_job,
                                    scratch_directory=args.scratch_directory,
                                    dft_functional=args.ex_functional,
                                    nexcited_states=args.ex_n,
                                    mprank=args.coupling_qfit_mom)
            )
        else:
            jobs.append(
                DALTONPDEExEnergyJob(name,
                                     charge=molecule.get_charge(),
                                     custom_run_script=args.ex_script,
                                     basis_set=args.ex_basis,
                                     cores_per_job=args.ex_cpus_per_job,
                                     scratch_directory=args.scratch_directory,
                                     dft_functional=args.ex_functional,
                                     nexcited_states=args.ex_n,
                                    mprank=args.coupling_qfit_mom)
            )

        potential_name = jobs[-1].get_jobname()  # get most recently added job'
        potential.save("{}.pot".format(potential_name))
        job_names.append(potential_name)

        os.chdir("..")

    if len(jobs) == 0:
        raise spectre.errors.SpectreRuntimeError("No chromophores identified with tag(s) '{}'".format(', '.join(args.c)))

    return jobs, job_names


def read_computed_chromophore_properties(molecules, chromophores, job_names, args):
    """ Reads excited properties for chromophores from log files

        :param molecules: the list of molecules
        :type molecules: list[Molecule]
        :param chromophores: list of indices for which molecules are chromophores
        :type chromophores: list[int]
        :param job_names: list of jobnames
        :type job_names: list[str]
        :param args: spectre settings object
        :type args: argparse.Namespace
        :return: list of excited state data.
        :rtype: list[SpectreExcitedStateData]
    """
    assert len(chromophores) == len(job_names)

    data = []

    for i, chromophore_index in enumerate(chromophores, start=1):
        molecule = molecules[chromophore_index]
        job_name = job_names[chromophore_index]
        name = "{0:04d}_{1:s}".format(i, molecule.get_name())

        os.chdir(name)

        try:
            energies, tr_dips, tr_moms, mom_order = spectre.readers.get_chromophore_peex_data(job_name, args.coupling_with_moments)
        except spectre.errors.SpectrePEEXFileNotFoundError:
            if args.is_dryrun:
                print("You requested --dryrun but the output file '{0:s}.out' was not found.".format(job_name))
                print("Please re-run the job without --dryrun to compute all files.")
            else:
                print("The file '{0:s}.out' was not found. There could be a problem with the calculation so please check all output in the folder {1:s}.".format(job_name, name))
            exit()
        else:
            if mom_order >= 0:
                data.append(SpectreExcitedStateData.from_data(energies, tr_dips, tr_moms, mom_order))
            else:
                raise ValueError("No data was found in {}".format(job_name))

        os.chdir("..")

    return data

# ---------------------------------------------
# ---------------------------------------------
# ---------------------------------------------


def couple_chromophores(molecules, chromophores, potentials, properties, args):
    """ Computes the exciton states for the chromophores.

        :param molecules: all molecules in the system
        :type molecules: list[Molecule]
        :param chromophores: chromohores in the system
        :type chromophores: list
        :param potentials: all potentials for all molecules in the system
        :type potentials: list
        :param properties: chromophore properties
        :type properties: list[SpectreExcitedStateDate]
        :param args: spectre settings object
        :type args: argparse.Namespace


        :return: exciton energies, transition dipoles and oscillator strengths
        :rtype: (list[float], list[list], list[float])
    """

    if args.verbose:
        print(header("COMPUTING COUPLINGS", 0))

        print(header("Coupling Settings:", 1))
        coupling_mode_str = "transition density fitted {}"
        coupling_orders = {0: 'charges',
                           1: 'charges and dipoles',
                           2: 'charges, dipoles and quadrupoles'}
        coupling_mode = coupling_mode_str.format(coupling_orders[args.coupling_qfit_mom])
        if not args.coupling_with_moments:
            coupling_mode = "transition dipoles"

        couplings_str = "J0"
        if args.do_polarization:
            couplings_str = couplings_str + " + J1"

        coupling_algorithm = "serial"
        if args.coupling_cpus > 1:
            coupling_algorithm = "parallel ({} cores)".format(args.coupling_cpus)
        print_option("couplings", couplings_str, "{0:s}")
        print_option("calculated from", coupling_mode, "{0:s}")
        print_option("algorithm", coupling_algorithm, "{0:s}")

        if args.do_polarization:
            print_option("induced mom. eps", args.coupling_inddip_eps, "{0:6.1e}")

    energies = numpy.ravel([prop.get_excitation_energies() for prop in properties])
    tr_dips = [prop.get_transition_dipoles() for prop in properties]

    # build coupling matrix
    coupling_matrix = compute_total_coupling(molecules, chromophores, potentials, properties, args)
    matstat(coupling_matrix)
    foerster_matrix = numpy.diag(numpy.ravel(energies)) + coupling_matrix

    # diagonalize to get coefficients
    exciton_energies, v = numpy.linalg.eigh(foerster_matrix)

    # we need to ravel the top layer of the tr_dips only
    tr_dips_ravel = []
    for i in range(len(chromophores)):
        for value in tr_dips.pop(0):
            tr_dips_ravel.append(value)

    # exciton transition dipoles and oscillator strengths
    exciton_tr_dips = []
    exciton_osc_str = []
    for i, (ei, vi) in enumerate(zip(exciton_energies, v.T)):
        tr_dip = numpy.zeros(3)
        for c, t in zip(vi, numpy.asarray(tr_dips_ravel)):
            tr_dip += c * t

        exciton_tr_dips.append(tr_dip)
        exciton_osc_str.append(2.0/3.0*ei*tr_dip.dot(tr_dip))

    s_out = output_dalton_ex_data(exciton_energies, exciton_osc_str, idx=1)
    if args.verbose:
        print(s_out)
    if args.write_file:
        base = os.path.splitext(args.input)[0]
        filename = "{0}_coupled.dat".format(base)
        with open(filename, "w") as f:
            f.write(s_out)

    return exciton_energies, numpy.asarray(exciton_tr_dips), numpy.asarray(exciton_osc_str)


def compute_direct_coupling(mols, props, ichrom, jchrom, iex, jex, args):
    """ Computes the direct Coulomb coupling between chromophores

        :param mols: molecules in the system
        :type mols: list[spectre.molecule.Molecule]
        :param props: excited state properties of the chromophores
        :type props: list[SpectreExcitedStateData]
        :param ichrom: the first chromophore of the system
        :type ichrom: int
        :param jchrom: the second chromophore of the system
        :type jchrom: int
        :param iex: the ith excited state of chromophore ichrom
        :type iex: int
        :param jex: the jth excited state of chromophore jchrom
        :type jex: int
        :param args: spectre settings object
        :type args: argparse.Namespace
    """
    # extract the information we need
    coord_i, tr_q_i, tr_d_i, tr_o_i, _ = get_chromophore_moments(mols, iex, ichrom, props)
    coord_j, tr_q_j, tr_d_j, tr_o_j, _ = get_chromophore_moments(mols, jex, jchrom, props)

    if args.coupling_with_moments:
        erg = 0.0
        for ci, qi, di, oi in zip(coord_i, tr_q_i, tr_d_i, tr_o_i):
            for cj, qj, dj, oj in zip(coord_j, tr_q_j, tr_d_j, tr_o_j):
                dr = cj - ci
                T0 = pepytools.tensor.T(0, dr)
                T1 = pepytools.tensor.T(1, dr)
                T2 = pepytools.tensor.T(2, dr)
                qB = pepytools.mulmom.MulMom(qj)
                qA = pepytools.mulmom.MulMom(qi)
                muB = pepytools.mulmom.MulMom(*dj)
                muA = pepytools.mulmom.MulMom(*di)

                if args.coupling_qfit_mom >= 0:
                    erg += (qB * T0 * qA)[0]

                if args.coupling_qfit_mom >= 1:
                    erg += (qB * T1 * muA)[0] - (muB * T1 * qA)[0]
                    erg -= (muB * T2 * muA)[0]

                if args.coupling_qfit_mom >= 2:
                    T3 = pepytools.tensor.T(3, dr)
                    T4 = pepytools.tensor.T(4, dr)
                    oB = pepytools.mulmom.MulMom(*oj)
                    oA = pepytools.mulmom.MulMom(*oi)
                    erg += 1.0 / 3.0 * ((qB * T2 * oA)[0] + (oB * T2 * qA)[0])
                    erg += 1.0 / 3.0 * ((muB * T3 * oA)[0] - (oB * T3 * muA)[0])
                    erg += 1.0 / 9.0 * (oB * T4 * oA)[0]

        return erg
    else:
        raise NotImplementedError("Transition dipole J0 couplings not implemented yet.")


def get_chromophore_moments(mols, iex, ichrom, props):
    imol = mols[ichrom]
    coord_i = imol.get_coordinates() * aa2au
    tr_q_i = props[ichrom].get_transition_density_fitted_charges()[iex]
    tr_d_i = props[ichrom].get_transition_density_fitted_dipoles()[iex]
    tr_o_i = props[ichrom].get_transition_density_fitted_quadrupoles()[iex]
    q = [[a] for a in tr_q_i]

    # build tr stuff for use with pepytools potential from_moments
    tr = {0: q, 1: tr_d_i, 2: tr_o_i}

    return coord_i, tr_q_i, tr_d_i, tr_o_i, tr


def compute_indirect_coupling(mols, pots, props, ichrom, jchrom, iex, jex, args):
    """ Computes the indirect Coulomb coupling between chromophores through a polarizable environment

        :param mols: molecules in the system
        :type mols: list[spectre.molecule.Molecule]
        :param pots: potentials
        :type pots: list[Potential]
        :param props: excited state properties of the chromophores
        :type props: list[SpectreExcitedStateData]
        :param ichrom: the first chromophore of the system
        :type ichrom: int
        :param jchrom: the second chromophore of the system
        :type jchrom: int
        :param iex: the ith excited state of chromophore ichrom
        :type iex: int
        :param jex: the jth excited state of chromophore jchrom
        :type jex: int
        :param args: spectre settings object
        :type args: argparse.Namespace
        :return: the induction energy
        :rtype: float
    """
    potij = build_chromophore_potential(pots, args, ichrom, jchrom)
    potij.make_transition_potential()

    coord_i, _, _, _, tr_i = get_chromophore_moments(mols, iex, ichrom, props)
    coord_j, _, _, _, tr_j = get_chromophore_moments(mols, jex, jchrom, props)

    # we need the potentials from the two chromophores which are dependent
    # on how we used to compute J0
    if args.coupling_with_moments:
        if args.coupling_qfit_mom >= 0:
            poti = pepytools.Potential.from_multipoles(coord_i, tr_i, max_k=2)
            potj = pepytools.Potential.from_multipoles(coord_j, tr_j, max_k=2)
    else:
        raise NotImplementedError("Transition dipole J1 couplings not implemented yet.")

    # Solve for A.F(J) (eq 12 in 10.1021/acs.jctc.5b00470)
    pot = potij + potj
    pol_mat = pepytools.util.get_polarization_matrix(pot)
    int_mat = pepytools.util.get_interaction_matrix(pot)
    field = pepytools.fields.get_static_field(pot)
    s = pepytools.solvers.IterativeDIISSolver(pol_mat, int_mat, field, verbose = False, threshold = args.coupling_inddip_eps)
    induced_dipoles = s.Solve()

    # Now get field at induced dipoles to compute F(I).(A.F(J))
    pot = potij + poti
    field = pepytools.fields.get_static_field(pot)

    return -field.dot(induced_dipoles)


def compute_total_coupling(mols, chroms, pots, props, args):
    """ Computes couplings between all chromophores in the system

        :param mols: molecules
        :type mols: list[Molecule]
        :param chroms: chromophores
        :type chroms: list[int]
        :param pots: potentials
        :type pots: list[Potential]
        :param props: excited state properties of the chromophores
        :type props: list[SpectreExcitedStateData]
        :param args: spectre settings object
        :type args: argparse.Namespace
        :return: coupling matrix
        :rtype: numpy.ndarray

        .. note:: The couplings are computed according to Steinmann and Kongsted, JCTC (2015),
           DOI: :url:`10.1021/acs.jctc.5b00470`

        The total coupling between two chromophores is given as

            :math:`J = J^{(0)} + J^{(1)}`

        where J^{(0)} is the direct (Coulomb) coupling which is calculated from
        partial charges fitted to reproduce the transition density from state
        i to a

            :math:`J^{(0)} = sum_{i \in I, j \in J} q_i q_j / |R_i - R_j|`

        or from transition dipole moments. A screening effect, J^{(1)}, from
        a polarizable medium is done through

            :math:`J^{(1)} = \mathbf{F}(I)\, \mathbf{A}\, \mathbf{F}(J)`

        where :math:`\mathbf{F}(I)` and :math:`\mathbf{F}(J)` are, respectively, the electric fields at the
        polarizable sites in the environment from chromophore :math:`I` and
        chromophore :math:`J`.
    """
    n = len(chroms) * args.ex_n

    direct_coupling = numpy.zeros((n, n))
    indirect_coupling = numpy.zeros_like(direct_coupling)

    t0 = numpy.asarray(time.time(), dtype=numpy.float64)
    if args.coupling_cpus > 1:
        # parallel version (should be able to run in serial as well)
        indices = []
        j0_jobs = []
        j1_jobs = []
        pool = multiprocessing.Pool(processes=args.coupling_cpus)
        for (chromophore_i, chromophore_j, iex, jex, imat, jmat) in chromophore_pair_ex_iterator(chroms, args):
            indices.append((imat, jmat))
            j0_jobs.append(
                pool.apply(compute_direct_coupling, args=(mols, props, chromophore_i, chromophore_j, iex, jex, args))
            )
            if args.do_polarization:
                j1_jobs.append(
                    pool.apply(compute_indirect_coupling, args=(mols, pots, props, chromophore_i, chromophore_j, iex, jex, args,))
                )

        for i, (imat, jmat) in enumerate(indices):
            direct_coupling[imat, jmat] = j0_jobs[i]
            direct_coupling[jmat, imat] = direct_coupling[imat, jmat]

        if args.do_polarization:
            for i, (imat, jmat) in enumerate(indices):
                indirect_coupling[imat, jmat] = j1_jobs[i]
                indirect_coupling[jmat, imat] = indirect_coupling[imat, jmat]
    else:
        # serial execution
        for (chromophore_i, chromophore_j, iex, jex, imat, jmat) in chromophore_pair_ex_iterator(chroms, args):

            direct_coupling[imat, jmat] = compute_direct_coupling(mols, props, chromophore_i, chromophore_j, iex, jex, args)
            direct_coupling[jmat, imat] = direct_coupling[imat, jmat]

            if args.do_polarization:
                indirect_coupling[imat, jmat] = compute_indirect_coupling(mols, pots, props, chromophore_i, chromophore_j, iex, jex, args)
                indirect_coupling[jmat, imat] = indirect_coupling[imat, jmat]

    t1 = numpy.asarray(time.time(), dtype=numpy.float64)
    if args.verbose:
        print("total coupling time [s]: {0:6.2f}".format(t1 - t0))

    return direct_coupling + indirect_coupling


def coulomb_coupling(coord_i, coord_j, tr_q_i, tr_q_j):
    """ computes the J0 coupling using partial atomic charges

        The charges are fitted to reproduce the ESP of a transition density
        and are placed on the atoms

        Arguments:
        coord_i -- coordinates of the i'th molecule
        coord_j -- coordinates of the j'th molecule
        tr_q_i -- charges of the i'th molecule
        tr_q_j -- charges of the j'th molecule

        Returns:
        the J0 coupling
    """
    assert len(coord_i) > 0
    assert len(coord_j) > 0
    assert len(coord_i) == len(tr_q_i)
    assert len(coord_j) == len(tr_q_j)
    coulomb_direct = 0.0
    for qi, ci in zip(tr_q_i, coord_i):
        for qj, cj in zip(tr_q_j, coord_j):
            dr = cj - ci
            coulomb_direct += qi*qj / numpy.sqrt(dr.dot(dr))
    return coulomb_direct


def build_chromophore_potential(potentials, args, *chroms):
    """ Build potential for chromophores listed in the args list

        :param potentials: all potentials for each part of the system
        :type potentials: list[pepytools.Potential]
        :param args: spectre settings object
        :type args: argparse.Namespace
        :param chroms: list of chromophores indices
        :type chroms: list[int]

        note: the construction of a chromophore potential
              is a bit funky because of the way
              the potential class works (or should one say how
              it does not work): We first build the correct list of potentials
              and then add the potentials (in a clunky way).
    """

    idx_potentials = []
    for j, pot in enumerate(potentials):
        if j in chroms:
            continue
        idx_potentials.append(j)

    if len(idx_potentials) == 0 and args.potential is None:
        print("No external potentials defined. Are you sure this [gas phase calculation] is what you want?")
        raise spectre.errors.SpectreValueError("No external potentials defined.")

    idx = idx_potentials[0]
    chromophore_potential = potentials[idx]
    for idx_potential in idx_potentials[1:]:
        chromophore_potential += potentials[idx_potential]

    if args.do_pde:
        # removes static part of potential because it is accounted for
        # by densities already
        chromophore_potential.make_transition_potential()

    if args.potential is not None:
        chromophore_potential += pepytools.Potential.from_file(args.potential)

    return chromophore_potential

    # # idx_potentials is a list of potentials we actually need
    # # if it has no elements
    # if len(idx_potentials) == 0:
    #     if args.potential is not None:
    #         chromophore_potential = pepytools.Potential.from_file(args.potential)
    #     else:
    #
    # else:
    #     idx = idx_potentials[0]
    #
    #     # external 'constant' potentials are added first
    #     if args.potential is not None:
    #         chromophore_potential = pepytools.Potential.from_file(args.potential) + potentials[idx]
    #     else:
    #         chromophore_potential = potentials[idx]
    #     for idx_potential in idx_potentials[1:]:
    #         chromophore_potential = chromophore_potential + potentials[idx_potential]
    #
    # return chromophore_potential


def chromophore_pair_ex_iterator(chroms, args):
    """ Iterator over excitations in pairs of chromophores

        Arguments:
        chroms -- chromophores over which to iterate
        args -- spectre options

        Returns:
        tuple of:
            ith chromophore
            jth chromophore
            kth excitation in ith chromophore
            lth excitation in jth chromophore
            matrix index for kth excitation in ith chromophore
            matrix index for lth excitation in jth chromophore

    """
    for i, chromophore_i in enumerate(chroms):
        for j, chromophore_j in enumerate(chroms):
            if i > j:
                for excitation_i, mat_index_i in enumerate(range(i*args.ex_n, (i+1)*args.ex_n)):
                    for excitation_j, mat_index_j in enumerate(range(j*args.ex_n, (j+1)*args.ex_n)):
                        yield chromophore_i, chromophore_j, excitation_i, excitation_j, mat_index_i, mat_index_j


def matstat(mat):
    """ Computes properties for the input matrix
    """
    i = numpy.argmax(numpy.abs(mat))
    (idx, jdx) = numpy.unravel_index(numpy.abs(mat).argmax(), mat.shape)

    print("MAX Element {2:9.6f} between elements {0:d} and {1:d}".format(idx+1, jdx+1, numpy.ravel(mat)[i]))


def output_dalton_ex_data(energies, oscillator_strengths, idx=1):
    """ Writes a DALTON-like output of spectral properties

        Note: Rotational strengths are not supplied as of now
              but is on the TODO.

        Arguments:
        energies -- Excitation energies
        osc_str -- oscillator strengths

        Optional Argument:
        idx -- the index of the system

        The data format is

        1234567890123456789012345678901234567890123456789012345678901234567890123456789

        @  1      i       dE            XX       osc         XX      R        R_L

        @  1      1     3.2874        0.0000   0.0017       0.000  -12.189  -12.160
        @  1      2     4.1101        0.0000   0.1076       0.000  110.709  110.478
        @  1      3     4.5190        0.0000   0.5327       0.000 -108.546 -109.723
        @  1      4     5.1764        0.0000   0.0012       0.000   -1.910   -1.888
        @  1      5     5.5422        0.0000   0.0019       0.000   -5.130   -5.386
        @  1      6     5.9525        0.0000   0.0149       0.000   -2.226   -2.913
    """
    s = "@  {0:1d}{1:>7d}{2:11.4f}{3:14.4f}{4:9.4f}{5:12.3f}{6:9.3f}{7:9.3f}\n"

    s_out = ""
    for i, (energy, osc_str) in enumerate(zip(energies, oscillator_strengths)):
        s_out += s.format(idx, i+1, energy, 0.0, osc_str, 0.0, 0.0, 0.0)

    return s_out[:-1]


def cleanup_work_directories(molecules):
    """ Compresses working folders to zip and removes them

        Scope: work_dir

        :param molecules: Molecules
        :type molecules: list[spectre.Molecule]
    """
    for i, molecule in enumerate(molecules, start=1):
        name = "{0:04d}_{1:s}".format(i, molecule.get_name())
        shutil.make_archive(name, 'zip', '.', name)
        shutil.rmtree(name)


if __name__ == "__main__":
    # attempt to guess scratch area before calculation even begins
    # if we cannot guess a scratch area report it as an error so
    # the calculation does not fail later
    slurm_scratch = os.environ.get('SCRATCH', None)
    spectre_scratch = os.environ.get('SPECTRE_TMPDIR', None)

    scratch_path = None
    scratch_path_str = "{}/SPECTRE_scratch_{}"
    if slurm_scratch is not None:
        scratch_path = scratch_path_str.format(slurm_scratch, getpass.getuser())
    elif spectre_scratch is not None:
        scratch_path = scratch_path_str.format(spectre_scratch, getpass.getuser())

    # check environment variables before computation starts
    # we will report on _ALL_ environment variables before
    # we potentially abort the program
    # a pretty fortran-style way of doing error checking here
    env_errors = 0
    try:
        os.environ['SPECTRE']
    except KeyError:
        print("ERROR: SPECTRE environment variable not pointing to installation share path.")
        env_errors += 1

    try:
        os.environ['CALCIT']
    except KeyError:
        print("ERROR: CALCIT environment variable not pointing to installation path.")
        env_errors += 1

    try:
        os.environ['DALTON']
    except KeyError:
        print("ERROR: DALTON environment variable not set to path of DALTON installation.")
        env_errors += 1

    try:
        os.environ['LOPROP']
    except KeyError:
        print("ERROR: LOPROP environment variable not set to path of LOPROP installation.")
        env_errors += 1

    if env_errors > 0:
        sys.exit("Please fix the above errors regarding the environment variables.")

    # The user can set the options for the potential calculations
    # through the --ntasks-per-node and --cpus-per-task options in the SLURM
    # submit script.
    # If not running on SLURM, we default to 1 and the user has
    # to specify this manually.
    pot_jobs_per_node = os.environ.get("SLURM_NTASKS_PER_NODE", 1)
    pot_cpus_per_job = os.environ.get("SLURM_CPUS_PER_TASK", 1)

    # for chromophore excitations we always default to 1 and 1 but the README should
    # specify that this is usually not wanted.
    # NB: Please note that using this setup it is not possible to run a single
    #     DALTON calculation on more than one node.
    chr_jobs_per_node = 1
    chr_cpus_per_job = 1

    # for coupling calculations we default to the serial unless
    # slurm tells us the number of cores on each node
    coup_cpus = os.environ.get("SLURM_JOB_CPUS_PER_NODE", 1)

    ap = argparse.ArgumentParser(description=__doc__)

    ap.add_argument("input", type=str, metavar="FILE", help="Input .pdb file.")
    ap.add_argument("-v", "--verbose", action="store_true", default=False)
    ap.add_argument("-s", "--scratch", dest="scratch_directory", metavar="DIRECTORY", default=scratch_path, help="Base directory for scratch storage. Default is extracted from either SCRATCH or SPECTRE_TMPDIR environment variables. Default %(default)s.")
    ap.add_argument("--dryrun", dest="is_dryrun", action="store_true", default=False, help="Specify this flag to skip any computations in either embedding potential calculations or excited state calculations. If the excited state calculations are present SPECTRE will compute the coupled spectrum.")
    ap.add_argument("--nowrite", dest="write_file", action="store_false", default=True, help="Do not write resulting spectra to files.")

    fragmentation_group = ap.add_argument_group("Fragmentation")
    fragmentation_group.add_argument("-f", type=str, dest='frag_settings', metavar="FILE", default=None, help="")

    potential_group = ap.add_argument_group("Embedding Potential Calculations")
    potential_group.add_argument("-p", dest="potential", default=None, action=ExpandPath, metavar="POTENTIAL", help="Adds a 'constant' PE-potential to the calculation, for example a protein or solvent shell.")
    potential_group.add_argument("--potential-no-pol", dest="do_polarization", default=True, action="store_false", help="Set this flag to disable polarization effects. This will also remove screening in the couplings between chromophores.")
    potential_group.add_argument("--potential-isopol", dest="do_isopol", default=False, action="store_true", help="Set this flag to only do isotropic polarizabilities instead of the full anisotropic polarizabilities.")
    potential_group.add_argument("--potential-multipole-order", type=int, default=2, choices=[0, 1, 2], help="Highest order multipole moment of the static part of the embedding potential. Choices are: %(choices)s. Default is %(default)s.")
    potential_group.add_argument("--potential-loprop-basis", metavar='BASIS', default="loprop-6-31+G*", help="Basis set to use for LoProp embedding potential calculations. Default is %(default)s.")
    potential_group.add_argument("--potential-functional", metavar='FUNCTIONAL', default=None, help="Selects a DFT functional for potential calculations. If not specified, HF is chosen as the default.")
    potential_group.add_argument("--potential-loprop-script", default=os.environ['SPECTRE'] + '/share/dalton_loprop.bash', metavar="SCRIPT", action=ExpandPath, help="Script to the LoProp potential for each chromophore. Default: %(default)s.")
    potential_group.add_argument("--potential-jobs-per-node", default=pot_jobs_per_node, type=int, metavar="JOBS_PER_NODE", help="Number of jobs to execute per node for potential calculation. This is number is usually equal to the number of cores available to you on a single node. Can be controlled with SLURM using the --ntasks-per-node option. Default is %(default)s.")
    potential_group.add_argument("--potential-cpus-per-job", default=pot_cpus_per_job, type=int, metavar="CPUS_PER_JOB", help="Number of cores per job. This number is usually low. Can be controlled with SLURM using the --cpus-per-task option. Default is %(default)s.")
    potential_group.add_argument("--potential-do-pde", dest="do_pde", default=False, action="store_true", help="Enables the use of PDEs. Default is false.")
    potential_group.add_argument("--potential-use-ml", dest="use_ml", default=False, action="store_true", help="Enables machine-learned LoProp embedding potentials. NB Forces an M0P1 potential.")
    potential_group.add_argument("--potential-ml-path", dest="ml_path", default=os.environ['SPECTRE'] + '/share/ml', metavar="PATH", action=ExpandPath, help="Path to ML data.")
    potential_group.add_argument("--potential-pde-basis", metavar='BASIS', default="6-31+G*", help="Basis set to use for PDE embedding potential calculations. Default is %(default)s.")
    potential_group.add_argument("--potential-pde-exch-factor", default=0.8, type=float, metavar="FACTOR", help="Scaling factor for the exchange-repulsion term in PDE. Default is %(default)s")
    potential_group.add_argument("--potential-pde-mon-script", default=os.environ['SPECTRE'] + '/share/dalton_pde_monomer.bash', metavar="SCRIPT", action=ExpandPath, help="Script to generate momomeric part of PDE potential for each chromophore. Default: %(default)s.")
    potential_group.add_argument("--potential-pde-dim-script", default=os.environ['SPECTRE'] + '/share/dalton_pde_dimer.bash', metavar="SCRIPT", action=ExpandPath, help="Script to generate dimeric part of PDE potential for each chromophore. Default: %(default)s.")

    chr_group = ap.add_argument_group("Excited State Chromophore Calculations")
    chr_group.add_argument("-c", type=str, nargs="+", metavar="NAME", help="Selects residue names to be excitonically coupled.")
    chr_group.add_argument('-r', metavar="DISTANCE", type=float, default=-1.0, help="Select additional fragments within DISTANCE of fragments from -c to be coupled excitonically. Mutually exclusive with -a.")
    chr_group.add_argument('-a', metavar="ID", nargs='+', type=int, help="Appends fragment indices to list of chromophores that are to be coupled excitonically. Mutually exclusive with -r.")
    chr_group.add_argument("-n", dest='ex_n', type=int, metavar="N", default=4, help="Number of excited states N to compute for each chromophore. Default is %(default)s.")
    chr_group.add_argument("--ex-state", type=int, default=0, help="State(s) to couple between chromophores.")
    chr_group.add_argument("--ex-basis", default="6-31+G*", metavar='BASIS', help="Basis set to use for the excited state calculations and coupling parameters. Default is %(default)s.")
    chr_group.add_argument("--ex-functional", default=None, metavar='FUNCTIONAL', help="Selects a DFT functional for excited state calculations. If not specified, HF is chosen.")
    chr_group.add_argument("--ex-script", default=os.environ['SPECTRE'] + '/share/dalton_excited.bash', metavar="SCRIPT", action=ExpandPath, help="Script to compute excited state calculations. Default: %(default)s.")
    chr_group.add_argument("--ex-jobs-per-node", default=chr_jobs_per_node, type=int, metavar="JOBS_PER_NODE", help="Number of jobs to execute per node for embedded chromophores. This is number is usually lower than the potential counterpart. Default is %(default)s.")
    chr_group.add_argument("--ex-cpus-per-job", default=chr_cpus_per_job, type=int, metavar="CPUS_PER_JOB", help="Number of cores per job. This number should almost always be equal to the number of cores available on your node. Default is %(default)s.")

    cpl_group = ap.add_argument_group("Coupling Parameters", description="""In case there are multiple chromophores selected through the -c keyword or other keywords, the chromophores will electronically couple through a term J = J^0 + J^1 where J^0 is computed always and J^1 depends on the environment. J^1 is always computed unless the environment is static or the --potential-no-pol option has been given.""")
    cpl_group.add_argument("--coupling-trdip", dest="coupling_with_moments", default=True, action="store_false", help="Set this flag to use the transition dipole moments instead of a transition density fitted multipole expansion (see option --coupling-qfit-mom) to compute the coupling elements between the excited states of the chromophores.")
    cpl_group.add_argument("--coupling-qfit-mom", choices=[0, 1, 2], default=0, type=int, help="The order of the multipole moments (0 is charges, 1 is charges and dipoles and so on) used to compute the couplings. Choices are: %(choices)s. Default is %(default)s.")
    cpl_group.add_argument("--coupling-inddip-eps", default=1.0e-8, type=float, metavar="EPS", help="threshold for the convergence of the induced dipoles in the J1 term. Default is %(default)s.")
    cpl_group.add_argument("--coupling-cpus", default=coup_cpus, type=int, metavar="CPUS_PER_NODE", help="Number of cores to use for computing the Foerster coupling matrix.")

    INPUT_ARGS = ap.parse_args()
    print(INPUT_ARGS)

    # do some error handling
    if INPUT_ARGS.c is None:
        print("No chromophores specified. Aborting.")
        exit()

    if INPUT_ARGS.scratch_directory is None:
        print("ERROR: SPECTRE could not set temporary work directory.")
        print("       Please use SCRATCH or SPECTRE_TMPDIR environment variables")
        print("       or the --scratch option.")
        exit()

    if INPUT_ARGS.do_pde and not has_h5py:
        print("ERROR: SPECTRE could not run because you requested a ")
        print("       PDE-type calculation (--potential-do-pde) but ")
        print("       such a calculation requires the h5py package.")
        exit()

    # what follows here is the proposed workflow along required packages
    #
    # Basic input should be at *minimum*:
    #   - ONE .pdb file
    #   - a list of chromophores to be found in the file from above
    #
    # for a very large system it will be beneficial to run with multiple
    # .pdb files due to speed and complexity of the calculations but this
    # will be done at a later time
    #
    # 1. Identify Chromophores through residue names
    #   -c --chromophores [strings]
    #
    # the chromophores are labelled with residue names from the keyword -c
    # and are appropriately marked in the structures.
    #
    # To obtain the correct coupling (J = J0 + J1) we must also have embedding
    # parameters for these molecules (specifically for J1)
    #
    # 2. Generate embedding potential for everything using FragIt and CalcIt
    molecules_, chromophores_, potentials_ = setup_chromophores(INPUT_ARGS)

    # generate PDE potentials if needed.
    if INPUT_ARGS.do_pde:
        generate_pde_potentials(molecules_, chromophores_, potentials_, INPUT_ARGS)

    #
    #
    # VIII. Computation of diagonal part of Foerster matrix along with
    # transition dipole moments (or transition density charges)
    properties_ = compute_chromophores(molecules_, potentials_, chromophores_, INPUT_ARGS)

    if len(chromophores_) > 1:
        energies_, tr_dips_, osc_str_ = couple_chromophores(molecules_, chromophores_, potentials_, properties_, INPUT_ARGS)

    cleanup_work_directories(molecules_)
